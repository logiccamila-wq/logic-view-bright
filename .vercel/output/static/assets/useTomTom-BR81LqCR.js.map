{"version":3,"file":"useTomTom-BR81LqCR.js","sources":["../../src/hooks/useTomTom.ts"],"sourcesContent":["import { useState } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\n\r\ninterface Coordinates {\r\n  lat: number;\r\n  lng: number;\r\n}\r\n\r\ninterface RouteResponse {\r\n  distance: number; // metros\r\n  duration: number; // segundos\r\n  geometry: {\r\n    coordinates: number[][];\r\n  };\r\n}\r\n\r\ninterface GeocodingResult {\r\n  position: {\r\n    lat: number;\r\n    lon: number;\r\n  };\r\n  address: {\r\n    freeformAddress: string;\r\n    country: string;\r\n    municipality?: string;\r\n  };\r\n}\r\n\r\nexport function useTomTom() {\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  /**\r\n   * Calcula rota entre dois pontos usando proxy autenticado\r\n   */\r\n  const calculateRoute = async (\r\n    start: Coordinates,\r\n    end: Coordinates,\r\n    vehicleType: 'car' | 'truck' = 'truck'\r\n  ): Promise<RouteResponse | null> => {\r\n    setLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      // Use OpenRouteService via authenticated proxy\r\n      const profile = vehicleType === 'truck' ? 'driving-hgv' : 'driving-car';\r\n      const { data, error: invokeError } = await supabase.functions.invoke('calculate-route', {\r\n        body: { \r\n          start: { lat: start.lat, lng: start.lng }, \r\n          end: { lat: end.lat, lng: end.lng }, \r\n          profile \r\n        }\r\n      });\r\n\r\n      if (invokeError) {\r\n        throw new Error(invokeError.message || 'Erro ao calcular rota');\r\n      }\r\n\r\n      return data;\r\n    } catch (err) {\r\n      console.error('Erro ao calcular rota:', err);\r\n      setError(err instanceof Error ? err.message : 'Erro desconhecido');\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Converte endereço em coordenadas usando proxy autenticado\r\n   */\r\n  const geocode = async (address: string): Promise<GeocodingResult | null> => {\r\n    setLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      const { data, error: invokeError } = await supabase.functions.invoke('geocode-address', {\r\n        body: { address }\r\n      });\r\n\r\n      if (invokeError) {\r\n        throw new Error(invokeError.message || 'Erro ao buscar endereço');\r\n      }\r\n\r\n      if (!data) {\r\n        setError('Endereço não encontrado');\r\n        return null;\r\n      }\r\n\r\n      return data;\r\n    } catch (err) {\r\n      console.error('Erro ao buscar endereço:', err);\r\n      setError(err instanceof Error ? err.message : 'Erro desconhecido');\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Busca endereço reverso (coordenadas -> endereço) usando proxy autenticado\r\n   */\r\n  const reverseGeocode = async (lat: number, lng: number): Promise<GeocodingResult | null> => {\r\n    setLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      const { data, error: invokeError } = await supabase.functions.invoke('geocode-address', {\r\n        body: { lat, lng }\r\n      });\r\n\r\n      if (invokeError) {\r\n        throw new Error(invokeError.message || 'Erro ao buscar localização');\r\n      }\r\n\r\n      if (!data) {\r\n        setError('Localização não encontrada');\r\n        return null;\r\n      }\r\n\r\n      return data;\r\n    } catch (err) {\r\n      console.error('Erro ao buscar localização:', err);\r\n      setError(err instanceof Error ? err.message : 'Erro desconhecido');\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Gera URL para tiles de mapa\r\n   * Nota: Agora usa OpenStreetMap por padrão (público, sem necessidade de API key)\r\n   */\r\n  const getTileUrl = (style: 'basic' | 'hybrid' | 'labels' = 'basic'): string => {\r\n    // Use OpenStreetMap tiles (public, no API key needed)\r\n    return `https://tile.openstreetmap.org/{z}/{x}/{y}.png`;\r\n  };\r\n\r\n  return {\r\n    calculateRoute,\r\n    geocode,\r\n    reverseGeocode,\r\n    getTileUrl,\r\n    loading,\r\n    error\r\n  };\r\n}"],"names":["useTomTom","loading","setLoading","useState","error","setError","calculateRoute","start","end","vehicleType","profile","data","invokeError","supabase","functions","invoke","body","lat","lng","Error","message","err","console","geocode","address","reverseGeocode","getTileUrl","style"],"mappings":"0CA4BO,SAASA,GAAY,CAC1B,KAAM,CAACC,EAASC,CAAU,EAAIC,EAAAA,SAAS,EAAK,EACtC,CAACC,EAAOC,CAAQ,EAAIF,EAAAA,SAAwB,IAAI,EA6GtD,MAAO,CACLG,eAzGqB,MACrBC,EACAC,EACAC,EAA+B,UACG,CAClCP,EAAW,EAAI,EACfG,EAAS,IAAI,EAEb,GAAI,CAEF,MAAMK,EAAUD,IAAgB,QAAU,cAAgB,cACpD,CAAEE,KAAAA,EAAMP,MAAOQ,CAAAA,EAAgB,MAAMC,EAASC,UAAUC,OAAO,kBAAmB,CACtFC,KAAM,CACJT,MAAO,CAAEU,IAAKV,EAAMU,IAAKC,IAAKX,EAAMW,GAAAA,EACpCV,IAAK,CAAES,IAAKT,EAAIS,IAAKC,IAAKV,EAAIU,GAAAA,EAC9BR,QAAAA,CAAAA,CACF,CACD,EAED,GAAIE,EACF,MAAM,IAAIO,MAAMP,EAAYQ,SAAW,uBAAuB,EAGhE,OAAOT,CACT,OAASU,EAAK,CACZC,eAAQlB,MAAM,yBAA0BiB,CAAG,EAC3ChB,EAASgB,aAAeF,MAAQE,EAAID,QAAU,mBAAmB,EAC1D,IACT,QAAA,CACElB,EAAW,EAAK,CAClB,CACF,EA2EEqB,QAtEc,MAAOC,GAAqD,CAC1EtB,EAAW,EAAI,EACfG,EAAS,IAAI,EAEb,GAAI,CACF,KAAM,CAAEM,KAAAA,EAAMP,MAAOQ,CAAAA,EAAgB,MAAMC,EAASC,UAAUC,OAAO,kBAAmB,CACtFC,KAAM,CAAEQ,QAAAA,CAAAA,CAAQ,CACjB,EAED,GAAIZ,EACF,MAAM,IAAIO,MAAMP,EAAYQ,SAAW,yBAAyB,EAGlE,OAAKT,IACHN,EAAS,yBAAyB,EAC3B,KAIX,OAASgB,EAAK,CACZC,eAAQlB,MAAM,2BAA4BiB,CAAG,EAC7ChB,EAASgB,aAAeF,MAAQE,EAAID,QAAU,mBAAmB,EAC1D,IACT,QAAA,CACElB,EAAW,EAAK,CAClB,CACF,EA6CEuB,eAxCqB,MAAOR,EAAaC,IAAiD,CAC1FhB,EAAW,EAAI,EACfG,EAAS,IAAI,EAEb,GAAI,CACF,KAAM,CAAEM,KAAAA,EAAMP,MAAOQ,CAAAA,EAAgB,MAAMC,EAASC,UAAUC,OAAO,kBAAmB,CACtFC,KAAM,CAAEC,IAAAA,EAAKC,IAAAA,CAAAA,CAAI,CAClB,EAED,GAAIN,EACF,MAAM,IAAIO,MAAMP,EAAYQ,SAAW,4BAA4B,EAGrE,OAAKT,IACHN,EAAS,4BAA4B,EAC9B,KAIX,OAASgB,EAAK,CACZC,eAAQlB,MAAM,8BAA+BiB,CAAG,EAChDhB,EAASgB,aAAeF,MAAQE,EAAID,QAAU,mBAAmB,EAC1D,IACT,QAAA,CACElB,EAAW,EAAK,CAClB,CACF,EAeEwB,WATiBA,CAACC,EAAuC,UAElD,iDAQP1B,QAAAA,EACAG,MAAAA,CAAAA,CAEJ"}